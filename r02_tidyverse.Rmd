---
title: "tidyverse"
date: Latest update `r format(Sys.time(), '%d %B, %Y')`
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---

```{r, include = F}

library(tidyverse)

```

------------------------------------------------------------------------

# INTRODUCTION

------------------------------------------------------------------------

Data transformation is a critical component of data analysis. You can use spreadsheets or similar to manage your data. However, this form of data manipulation/transformation should be limited to the process of creating the primary data set. There are several reasons for this. **First and foremost, spreadsheets do NOT keep records of your edits.** If you make any mistake during the process of data transformation, it will be unnoticed and cannot be recovered for most cases. **Second, spreadsheets are simply unsuitable for data transformation.** You may need to iterate the same transformation multiple times - you will make errors sooner or later.

`tidyverse` is an R package that allows for effective data manipulation, visualization and more. In this page, I will focus on a couple of functions that I often use. A more comprehensive guide is available [here](https://r4ds.had.co.nz/index.html). `tidyverse` is not a default package, so you have to type in the following script every time you open up the R studio:

```{r, eval = F}
# if you have not installed, install first with install.packages()
# otherwise skip the first line

#install.packages("tidyverse")
library(tidyverse)

```

`tidyverse` is a collection of many useful packages, including `ggplot2` and `dplyr`.

------------------------------------------------------------------------

# BASIC FUNCTIONS

------------------------------------------------------------------------

Below, I will introduce some useful 'basic' functions, followed by guidance on how to combine them via pipe. Before you proceed, let's check the data set we will use for this exercise. R provides a nice data set `iris` , which is well suited for this type of exercise. You can check details of the data using `View()` function.

```{r, echo=FALSE}
iris <- as_tibble(iris) # change data frame format to tibble
View(iris)
```

Also, you can check variables (column names) as follows:

```{r}
colnames(iris)
```

## `filter()`: filter rows

You may need to "filter" data based on some criteria. `filter()` can help you on this. Let's select rows that belong to one species. For character & factor variables, you will need to double-quote them:

```{r}
unique(iris$Species) # check what species exist in the data
df0 <- filter(iris, Species == "setosa")
```

You can choose two or more species at once:

```{r}
df1 <- filter(iris, Species %in% c("setosa", "versicolor"))
```

Alternatively, you might want to exclude data that belong to a specific species. You can do this by:

```{r}
df2 <- filter(iris, Species != "virginica")
```

Numeric variables can also be used to select rows:

```{r}
df3 <- filter(iris, Petal.Width > 1.0) # greater than 1.0
df4 <- filter(iris, Petal.Width >= 1.0) # equal or greater than 1.0
df5 <- filter(iris, Petal.Width < 1.0) # less than 1.0
df6 <- filter(iris, Petal.Width <= 1.0) # less than 1.0
```

### Exercise

-   Check unique elements of the column `Species` in `df0`, `df1`, and `df2`
-   Check the range of `Petal.Width` for `df3` to `df6` . Use `range()` function to find a range of values in the column.
-   Select rows with sepal length greater than 5.0 in `iris`.

## `select()`: select columns

You can also select columns. Let's select `Petal.Width` using `select()`. This function takes column names as arguments.

```{r}

select(iris, Petal.Width)
```

You can select multiple columns like:

```{r}

select(iris, Petal.Width, Petal.Length)
```

Or remove specific columns with `-` notation:

```{r}

select(iris, -Petal.Width)
```

You may pick columns starting with specific strings:

```{r}

select(iris, starts_with("Petal"))
```

Or columns ending with specific strings:

```{r}

select(iris, ends_with("Width"))
```

### Exercise

-   Select columns `Petal.Width` and `Species`
-   Select columns other than `Species`
-   Select columns ending with `Length`

## `mutate()`: add new columns

Somtimes, you want to add new columns to the data frame. We can add new columns with the same number of elements (i.e., number of rows). We use `mutate()`:

```{r}

# new variable x
x <- 1:nrow(iris)

# add x to iris as "new_bar"
iris_x <- mutate(iris, new_var = x)

iris_x
```

## `arrange()`: arrange row orders

You can arrange order of rows with `arrange()` function. Let's arrange the data by Sepal.Width. By default, the data will be arrange in an ascending order:

```{r}
arrange(iris, Sepal.Width)

```

You can do a descending order by wrapping the column name with `desc()`

```{r}
arrange(iris, desc(Sepal.Width))
```

### Exercise

-   Arrange rows by `Species`

## `slice()` : choose specific rows

You can choose specific number of rows using `slice()`. You just need give the function row numbers to be selected:

```{r}
# select row 1
slice(iris, 1)

# select row 1 to 5
slice(iris, 1:5)

# select row 1 to 3
slice(iris, c(1, 3))
```

### Exercise

-   Choose rows 7 to 10

-   Choose rows 5, 9, and 98

## `%>%`: pipe

Data manipulation usually involves multiple processes. For example, you might want to reduce the number of columns and then filter rows. This can be done with the following script:

```{r}

df_selected <- select(iris, Sepal.Length, Species)
df_final <- filter(df_selected, Species == "setosa")

print(df_final)
```

However, as the number of processes increases, the temporary data frames will increase - this is problematic from the perspective of readability of codes (critical to avoiding potential errors).

Most functions in `tidyverse` package will take a data frame as the first argument and then let you enter the command that you want to perform in the second argument. This arrangement is very useful when combined **with pipe notation `%>%`**. It is a little tricky to explain how pipes work, so let's take a look at the following example:

```{r}

df_final <- iris %>% 
  select(Sepal.Length,
         Species) %>% 
  filter(Species == "setosa")

print(df_final)
```

The above script performs commands identical to the first example - but the codes are sequentially organized with pipes, which **pass the data frame to the next function as the first argument**. You can add multiple manipulations as many as you want with pipes:

```{r}

df_short_sepal <- iris %>% 
  select(Sepal.Length,
         Species) %>% 
  filter(Species == "setosa") %>% 
  arrange(Sepal.Length) %>% 
  slice(1:3)

print(df_short_sepal)
```

### Exercise

Using pipe, do the following:

-   Find data rows that contain the three widest `Sepal.Width` for species `virginica`

-   Arrange data rows according to `Sepal.Length` and add a new column with sequential ID numbers (0 - 100) from the shortest to the longest `Sepal.Length`

------------------------------------------------------------------------

# GROUP MANIPULATION

------------------------------------------------------------------------

## Example

One of the beauties in `tidyverse` is its ability to manipulate data by group - for example, it is very common for ecologists to show summary statistics by species. Such manipulation can be cumbersome, but with `tidyverse`, magic will happen. We will use `group_by()` function to create a group structure in a data frame:

```{r}
iris_grouped <- group_by(iris, Species)
print(iris_grouped)
```

It looks like there is no change in the data structure, but in the output, it says there are species groups based on `Species` column. Once you created a group structure in a data frame, you can manipulate data by group using `summarize()` function. Let's estimate the means of `Sepal.Length` for each species. Pipes are particularly useful here:

```{r}
iris %>% 
  group_by(Species) %>% 
  summarize(mean_sepal_length = mean(Sepal.Length)) %>% 
  print()
```

You can use any function to calculate summary statistics. For example, add another 'summarized' column for SDs:

```{r}
iris %>% 
  group_by(Species) %>% 
  summarize(mean_sepal_length = mean(Sepal.Length),
            sd_sepal_length = sd(Sepal.Length)) %>% 
  print()
```

This is a very basic example - you can tweak and combine functions in different ways to achieve your data manipulation effectively.

### Exercise

-   Estimate the means and SDs of `Sepal.Width` by species.

-   Which species has the widest `Sepal.Width` on average? Combine `group_by()`, `summarize()`, `arrange()`, and `slice()` functions to extract the row with the widest mean of `Sepal.Width`.
